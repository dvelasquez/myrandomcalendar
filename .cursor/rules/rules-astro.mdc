---
globs: *.astro,src/actions/**/*.ts,middleware.ts
alwaysApply: false
---

# Astro-Specific Rules

## üìä Data Fetching Architecture (CRITICAL)

### **Preferred Pattern: Server-Side Data Fetching**
- ‚úÖ **Astro Actions**: Use `defineAction` for all server-side operations
- ‚úÖ **Server-Side Fetching**: Data fetching should happen in `.astro` components
- ‚úÖ **Props Passing**: Pass fetched data as props to React components
- ‚úÖ **No Client-Side Fetching**: Avoid `useEffect` for initial data loading

### **Implementation Pattern**
```typescript
// ‚úÖ CORRECT: Astro page (.astro)
---
import { getScheduleBlocks } from '../actions/schedule-blocks';

// Fetch data server-side
let scheduleBlocks = [];
if (user) {
  scheduleBlocks = await getScheduleBlocks(user.id);
}
---

<ReactComponent 
  initialData={scheduleBlocks}
  client:load
/>
```

```typescript
// ‚ùå AVOID: React component fetching
const [data, setData] = useState([]);

useEffect(() => {
  // Don't do this for initial data
  fetchData();
}, []);
```

### **Benefits**
- **Performance**: Data available immediately on page load
- **SEO**: Content present in initial HTML
- **UX**: No loading states or empty screens
- **Architecture**: Clean separation of concerns

## üèóÔ∏è Service Layer Pattern (CRITICAL)

### **When to Use Services**
- Complex pages with multiple data sources
- Business logic that needs to be testable
- Data transformation and aggregation
- Reusable logic across multiple pages

### **Service Structure**
```typescript
// services/{page}-handler.ts
export interface {Page}PageData {
  // Structured data interface
  data1: Type1[];
  data2: Type2[];
  formOptions: FormOptions;
  successMessage?: string;
  errorMessage?: string;
}

export async function handle{Page}Page(
  context: ActionAPIContext,
  ...params
): Promise<{Page}PageData | null> {
  try {
    if (!context.locals.user) {
      return null;
    }

    // Pure business logic
    // Data fetching and transformation
    // No presentation concerns
    
    return {
      data1,
      data2,
      formOptions,
      successMessage,
      errorMessage
    };
  } catch (error) {
    console.error('Error in handle{Page}Page:', error);
    return null;
  }
}
```

### **Benefits**
- **Testable**: Pure functions with no side effects
- **Reusable**: Can be used by actions and other services
- **Maintainable**: Clear separation of business logic
- **Type Safe**: Full TypeScript coverage

## üìÑ Page Data Actions Pattern (CRITICAL)

### **For Complex Pages**
When pages have complex data fetching, use this pattern:

1. **Service Layer**: Pure business logic
2. **Action Layer**: API interface with validation
3. **Template Layer**: Presentation only

### **Implementation**
```typescript
// actions/get{Page}Data.ts
export const get{Page}DataAction = defineAction({
  accept: 'form',
  input: z.object({
    // Page parameters
    editId: z.string().optional(),
    successMessage: z.string().optional(),
    errorMessage: z.string().optional(),
  }),
  handler: async (params, context): Promise<{Page}PageData> => {
    try {
      if (!context.locals.user) {
        throw new ActionError({
          code: 'UNAUTHORIZED',
          message: 'You must be logged in to access this page'
        });
      }

      const data = await handle{Page}Page(context, ...params);
      
      if (!data) {
        throw new ActionError({
          code: 'UNAUTHORIZED',
          message: 'You must be logged in to access this page'
        });
      }

      return data;
    } catch (error) {
      console.error('Error in get{Page}DataAction:', error);
      if (error instanceof ActionError) {
        throw error;
      }
      throw new ActionError({
        code: 'INTERNAL_SERVER_ERROR',
        message: 'Failed to fetch page data',
      });
    }
  },
});
```

### **Template Usage**
```astro
---
import { actions } from 'astro:actions';

// Get query parameters
const url = new URL(Astro.request.url);
const editId = url.searchParams.get('edit');
const successMessage = url.searchParams.get('success');

// Fetch page data using action
let pageData = null;
if (user) {
  try {
    const formData = new FormData();
    if (editId) formData.append('editId', editId);
    if (successMessage) formData.append('successMessage', successMessage);
    
    const result = await Astro.callAction(actions.feature.getPageData, formData);
    if (result.data) {
      pageData = result.data;
    }
  } catch (error) {
    console.error('Error fetching page data:', error);
  }
}
---

<Layout>
  {user && pageData ? (
    <!-- Use structured pageData -->
    <div>
      <h1>{pageData.editingItem ? 'Edit' : 'Create'}</h1>
      <!-- Form and content using pageData -->
    </div>
  ) : (
    <!-- Authentication required -->
  )}
</Layout>
```

## üéØ Astro Actions API (Latest)

### **Actions Definition**
Actions are defined in a `server` object exported from `src/actions/index.ts`:

```typescript
// src/actions/index.ts
import { defineAction } from 'astro:actions';
import { z } from 'astro:schema';

export const server = {
  myAction: defineAction({
    accept: 'form', // or 'json'
    input: z.object({
      name: z.string(),
      email: z.string().email(),
    }),
    handler: async (input, context) => {
      // Handle the action
      return { success: true, data: input };
    }
  })
};
```

### **Calling Actions from Forms**
```astro
---
import { actions } from 'astro:actions';
---

<form method="POST" action={actions.myAction}>
  <input name="name" type="text" required />
  <input name="email" type="email" required />
  <button type="submit">Submit</button>
</form>

<!-- Handle action results -->
{(() => {
  const result = Astro.getActionResult(actions.myAction);
  if (result && !result.error) {
    return <p class="success">Success: {result.data.message}</p>;
  }
  if (result?.error) {
    return <p class="error">Error: {result.error.message}</p>;
  }
})()}
```

### **Calling Actions from Client-Side**
```typescript
// In React components or client-side scripts
import { actions } from 'astro:actions';

const handleSubmit = async (formData) => {
  const result = await actions.myAction(formData);
  
  if (result.error) {
    console.error('Action failed:', result.error);
  } else {
    console.log('Action succeeded:', result.data);
  }
};
```

### **Action Error Handling**
```typescript
import { ActionError, defineAction } from 'astro:actions';

export const server = {
  protectedAction: defineAction({
    handler: async (input, context) => {
      // ‚úÖ UPDATED: Use context.locals.user for better performance
      if (!context.locals.user) {
        throw new ActionError({ 
          code: 'UNAUTHORIZED',
          message: 'Authentication required' 
        });
      }
      
      // Handle the action
      return { success: true };
    }
  })
};
```

## üéØ Astro Best Practices

### **File Structure**
- Use `.astro` files for pages and layouts
- Keep server-side logic in the frontmatter (`---` sections)
- Use `client:*` directives for React components that need hydration
- Prefer `client:load` for immediate hydration, `client:idle` for performance

### **Data Fetching**
- Always fetch data in Astro frontmatter, not in React components
- Use Astro Actions (`defineAction`) for form submissions and mutations
- Pass data as props to React components
- Use `astro:db` for database operations

### **Authentication**
- ‚úÖ **Use `context.locals.user`** in actions for better performance
- ‚ùå **Avoid `auth.api.getSession()`** in actions (use middleware instead)
- Check authentication status in Astro frontmatter
- Pass user data as props to React components

### **Styling**
- Use TailwindCSS classes directly in Astro components
- Prefer utility classes over custom CSS
- Use CSS modules only when necessary

### **Performance**
- Leverage Astro's static generation capabilities
- Use `client:visible` for components that only need to hydrate when visible
- Minimize JavaScript bundle size by using appropriate client directives

## üîß Common Astro Patterns

### **Page with Authentication**
```astro
---
import { actions } from 'astro:actions';

// ‚úÖ UPDATED: Use context.locals.user from middleware
const { user } = Astro.locals;

if (!user) {
  return Astro.redirect('/login');
}

// Fetch data server-side using actions
let pageData = null;
try {
  const formData = new FormData();
  const result = await Astro.callAction(actions.feature.getPageData, formData);
  if (result.data) {
    pageData = result.data;
  }
} catch (error) {
  console.error('Error fetching page data:', error);
}
---

<Layout title="Dashboard">
  <DashboardComponent user={user} data={pageData} client:load />
</Layout>
```

### **Form Handling with Actions**
```astro
---
import { actions } from 'astro:actions';
---

<form method="POST" action={actions.updateProfile}>
  <input name="name" type="text" required />
  <input name="email" type="email" required />
  <button type="submit">Update Profile</button>
</form>

<!-- Handle action results -->
{(() => {
  const result = Astro.getActionResult(actions.updateProfile);
  if (result && !result.error) {
    return <p class="success">Profile updated successfully!</p>;
  }
  if (result?.error) {
    return <p class="error">Error: {result.error.message}</p>;
  }
})()}
```

### **Calling Actions from Server-Side**
```astro
---
import { actions } from 'astro:actions';

// Call action from server-side
const searchQuery = Astro.url.searchParams.get('search');
if (searchQuery) {
  const { data, error } = await Astro.callAction(actions.findProduct, { 
    query: searchQuery 
  });
  
  if (error) {
    console.error('Search failed:', error);
  } else {
    // Use the data
    const products = data.products;
  }
}
---
```

## üîÑ Complex Page Refactoring Guidelines

### **When to Refactor**
Refactor `.astro` files when they have:
- **200+ lines** of mixed logic
- **Multiple data sources** (database, APIs, calculations)
- **Complex business logic** in templates
- **Hard to test** functionality
- **Poor maintainability** due to mixed concerns

### **Refactoring Process**
1. **Identify Logic**: Extract business logic from template
2. **Create Service**: Move logic to `services/{page}-handler.ts`
3. **Create Action**: Add `actions/get{Page}Data.ts`
4. **Update Template**: Simplify to presentation only
5. **Test**: Ensure functionality remains the same

### **Before vs After**
```typescript
// ‚ùå BEFORE: Mixed logic in template
---
const { user } = Astro.locals;
const url = new URL(Astro.request.url);
const editId = url.searchParams.get('edit');

// Complex data fetching
let scheduleBlocks = [];
let editingBlock;
if (user) {
  try {
    const { data, error } = await Astro.callAction(actions.schedule.getScheduleBlocks, new FormData());
    if (!error && data) {
      scheduleBlocks = data;
      if (editId) {
        editingBlock = scheduleBlocks.find(block => block.id === editId);
      }
    }
  } catch (error) {
    console.error('Error fetching schedule blocks:', error);
  }
}
---

// ‚úÖ AFTER: Clean separation
---
import { actions } from 'astro:actions';

const { user } = Astro.locals;
const url = new URL(Astro.request.url);
const editId = url.searchParams.get('edit');

// Simple data fetching
let pageData = null;
if (user) {
  try {
    const formData = new FormData();
    if (editId) formData.append('editId', editId);
    
    const result = await Astro.callAction(actions.schedule.getMaintainerPageData, formData);
    if (result.data) {
      pageData = result.data;
    }
  } catch (error) {
    console.error('Error fetching page data:', error);
  }
}
---
```

### **Benefits of Refactoring**
- **50%+ Reduction** in template complexity
- **100% Testable** business logic
- **Better Performance** with optimized data fetching
- **Easier Maintenance** with clear separation
- **Type Safety** throughout the application

## üîí Security with Actions

### **Authorization in Actions**
```typescript
import { ActionError, defineAction } from 'astro:actions';

export const server = {
  getUserSettings: defineAction({
    handler: async (input, context) => {
      // ‚úÖ UPDATED: Use context.locals.user for better performance
      if (!context.locals.user) {
        throw new ActionError({ code: 'UNAUTHORIZED' });
      }
      
      return { settings: context.locals.user.settings };
    }
  })
};
```

### **Middleware Gating**
```typescript
// src/middleware.ts
import { defineMiddleware } from 'astro:middleware';
import { getActionContext } from 'astro:actions';

export const onRequest = defineMiddleware(async (context, next) => {
  const { action } = getActionContext(context);
  
  // Gate actions that require authentication
  if (action?.calledFrom === 'rpc') {
    if (!context.cookies.has('user-session')) {
      return new Response('Forbidden', { status: 403 });
    }
  }
  
  return next();
});
```
