---
globs: *.astro,src/actions/**/*.ts,middleware.ts
alwaysApply: false
---

# Astro-Specific Rules

## 📊 Data Fetching Architecture (CRITICAL)

### **Preferred Pattern: Server-Side Data Fetching**
- ✅ **Astro Actions**: Use `defineAction` for all server-side operations
- ✅ **Server-Side Fetching**: Data fetching should happen in `.astro` components
- ✅ **Props Passing**: Pass fetched data as props to React components
- ✅ **No Client-Side Fetching**: Avoid `useEffect` for initial data loading

### **Implementation Pattern**
```typescript
// ✅ CORRECT: Astro page (.astro)
---
import { getScheduleBlocks } from '../actions/schedule-blocks';

// Fetch data server-side
let scheduleBlocks = [];
if (user) {
  scheduleBlocks = await getScheduleBlocks(user.id);
}
---

<ReactComponent 
  initialData={scheduleBlocks}
  client:load
/>
```

```typescript
// ❌ AVOID: React component fetching
const [data, setData] = useState([]);

useEffect(() => {
  // Don't do this for initial data
  fetchData();
}, []);
```

### **Benefits**
- **Performance**: Data available immediately on page load
- **SEO**: Content present in initial HTML
- **UX**: No loading states or empty screens
- **Architecture**: Clean separation of concerns

## 🎯 Astro Actions API (Latest)

### **Actions Definition**
Actions are defined in a `server` object exported from `src/actions/index.ts`:

```typescript
// src/actions/index.ts
import { defineAction } from 'astro:actions';
import { z } from 'astro:schema';

export const server = {
  myAction: defineAction({
    accept: 'form', // or 'json'
    input: z.object({
      name: z.string(),
      email: z.string().email(),
    }),
    handler: async (input, context) => {
      // Handle the action
      return { success: true, data: input };
    }
  })
};
```

### **Calling Actions from Forms**
```astro
---
import { actions } from 'astro:actions';
---

<form method="POST" action={actions.myAction}>
  <input name="name" type="text" required />
  <input name="email" type="email" required />
  <button type="submit">Submit</button>
</form>

<!-- Handle action results -->
{(() => {
  const result = Astro.getActionResult(actions.myAction);
  if (result && !result.error) {
    return <p class="success">Success: {result.data.message}</p>;
  }
  if (result?.error) {
    return <p class="error">Error: {result.error.message}</p>;
  }
})()}
```

### **Calling Actions from Client-Side**
```typescript
// In React components or client-side scripts
import { actions } from 'astro:actions';

const handleSubmit = async (formData) => {
  const result = await actions.myAction(formData);
  
  if (result.error) {
    console.error('Action failed:', result.error);
  } else {
    console.log('Action succeeded:', result.data);
  }
};
```

### **Action Error Handling**
```typescript
import { ActionError, defineAction } from 'astro:actions';

export const server = {
  protectedAction: defineAction({
    handler: async (input, context) => {
      // Check authentication
      if (!context.locals.user) {
        throw new ActionError({ 
          code: 'UNAUTHORIZED',
          message: 'Authentication required' 
        });
      }
      
      // Handle the action
      return { success: true };
    }
  })
};
```

## 🎯 Astro Best Practices

### **File Structure**
- Use `.astro` files for pages and layouts
- Keep server-side logic in the frontmatter (`---` sections)
- Use `client:*` directives for React components that need hydration
- Prefer `client:load` for immediate hydration, `client:idle` for performance

### **Data Fetching**
- Always fetch data in Astro frontmatter, not in React components
- Use Astro Actions (`defineAction`) for form submissions and mutations
- Pass data as props to React components
- Use `astro:db` for database operations

### **Authentication**
- Use `auth.api.getSession()` in middleware and Astro pages
- Check authentication status in Astro frontmatter
- Pass user data as props to React components

### **Styling**
- Use TailwindCSS classes directly in Astro components
- Prefer utility classes over custom CSS
- Use CSS modules only when necessary

### **Performance**
- Leverage Astro's static generation capabilities
- Use `client:visible` for components that only need to hydrate when visible
- Minimize JavaScript bundle size by using appropriate client directives

## 🔧 Common Astro Patterns

### **Page with Authentication**
```astro
---
import { auth } from '../lib/better-auth';
import { redirect } from 'astro:actions';

const session = await auth.api.getSession({
  headers: Astro.request.headers
});

if (!session) {
  return redirect('/login');
}

// Fetch data server-side
const data = await fetchUserData(session.user.id);
---

<Layout title="Dashboard">
  <DashboardComponent user={session.user} data={data} client:load />
</Layout>
```

### **Form Handling with Actions**
```astro
---
import { actions } from 'astro:actions';
---

<form method="POST" action={actions.updateProfile}>
  <input name="name" type="text" required />
  <input name="email" type="email" required />
  <button type="submit">Update Profile</button>
</form>

<!-- Handle action results -->
{(() => {
  const result = Astro.getActionResult(actions.updateProfile);
  if (result && !result.error) {
    return <p class="success">Profile updated successfully!</p>;
  }
  if (result?.error) {
    return <p class="error">Error: {result.error.message}</p>;
  }
})()}
```

### **Calling Actions from Server-Side**
```astro
---
import { actions } from 'astro:actions';

// Call action from server-side
const searchQuery = Astro.url.searchParams.get('search');
if (searchQuery) {
  const { data, error } = await Astro.callAction(actions.findProduct, { 
    query: searchQuery 
  });
  
  if (error) {
    console.error('Search failed:', error);
  } else {
    // Use the data
    const products = data.products;
  }
}
---
```

## 🔒 Security with Actions

### **Authorization in Actions**
```typescript
import { ActionError, defineAction } from 'astro:actions';

export const server = {
  getUserSettings: defineAction({
    handler: async (input, context) => {
      // Check authentication from context.locals
      if (!context.locals.user) {
        throw new ActionError({ code: 'UNAUTHORIZED' });
      }
      
      return { settings: context.locals.user.settings };
    }
  })
};
```

### **Middleware Gating**
```typescript
// src/middleware.ts
import { defineMiddleware } from 'astro:middleware';
import { getActionContext } from 'astro:actions';

export const onRequest = defineMiddleware(async (context, next) => {
  const { action } = getActionContext(context);
  
  // Gate actions that require authentication
  if (action?.calledFrom === 'rpc') {
    if (!context.cookies.has('user-session')) {
      return new Response('Forbidden', { status: 403 });
    }
  }
  
  return next();
});
```
